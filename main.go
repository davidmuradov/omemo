package main

import (
	"fmt"
	//"crypto/ed25519"
	"crypto/ecdh"
	"crypto/rand"
	//"encoding/base64"
	//"crypto/sha256"
	//"crypto/hmac"
)

// Constants
const info string = "OMEMO X3DH"
const num_prekeys uint8 = 100
const min_prekeys uint8 = 25

// GenKeyPair returns a multipurpose public key and err from a random
// PrivateKey generated by ed25519. Can be used to generate
// a user's long-term Public Identity Key for the X3DH protocol, an
// ephemeral key, etc.
func GenKeyPair() (*ecdh.PublicKey, *ecdh.PrivateKey, error) {
	ell := ecdh.X25519()
	sK,err := ell.GenerateKey(rand.Reader)
	PK := sK.PublicKey()
	//pub_pri := private.Public()
	//fmt.Printf("%T",private)
	//fmt.Println(private,"\n")
	//fmt.Printf("%T",pub_pri)
	//fmt.Println(pub_pri,"\n")
	//fmt.Printf("%T",pub)
	//fmt.Println(pub,"\n")
	//PK, sK, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, nil, err
	}
	return PK, sK, nil
}

//func SignKey(sK , )

// Gen

/*
Encode encodes an X25519 public key PK into a byte sequence
The recommended encoding consists of some single-byte constant
to represent the type of curve, followed by little-endian encoding
of the u-coordinate as specified in [1].

func Encode(PK *ecdh.PublicKey) []byte {}
*/


// DH(PK1,PK2) is the shared secret output from an ecdh function involving
// keypairs involving public keys PK1 and PK2

func DH(PK1 *ecdh.PrivateKey, PK2 *ecdh.PublicKey) ([]byte, error) {
	shared, err := PK1.ECDH(PK2)
	if err != nil {
		return nil, err
	}
	return shared, nil
}


func main() {
	IK_A,sK_A,_ := GenKeyPair() // Alice keys
	IK_B,sK_B,_ := GenKeyPair() // Bob keys
	alice_DH,_ := DH(sK_A,IK_B)
	bob_DH,_ := DH(sK_B,IK_A)
	fmt.Println(alice_DH,"\n")
	fmt.Println(bob_DH,"\n")
	//slice := ed25519.Sign(SK,IK)
	//fmt.Println(len(slice))
	//EK,_,_ := GenKeyPair(x25519) // A user's ephemeral key
	// SPK := 
}
