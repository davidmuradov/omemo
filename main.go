package main

import (
	"fmt"
	//"encoding/hex"
	//"math/big"
	//"encoding/binary"
	"crypto/ed25519"
	"crypto/ecdh"
	"crypto/rand"
	//"crypto/ecdsa"
	//"encoding/base64"
	//"crypto/sha256"
	//"crypto/hmac"
	"github.com/jamesruan/sodium"
)

// Constants
const info string 			= "OMEMO X3DH"
const num_prekeys uint8 		= 100
const min_prekeys uint8 		= 25

// GenKeyPair returns a multipurpose public key and err from a random
// PrivateKey generated by ecdh. Can be used to generate
// a user's long-term Public Identity Key for the X3DH protocol, an
// ephemeral key, etc.
func GenCurveKeyPair() (*ecdh.PublicKey, *ecdh.PrivateKey, error) {
	elliptic_curve := ecdh.X25519()
	sK,err := elliptic_curve.GenerateKey(rand.Reader)
	fmt.Println(sK)
	PK := sK.PublicKey()
	if err != nil {
		return nil, nil, err
	}
	return PK, sK, nil
}

func GenEdKeyPair() (ed25519.PublicKey, ed25519.PrivateKey, error) {
	PK, sK, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, nil, err
	}
	return PK, sK, nil
}

func ReturnCurveKeyByte(sK *ecdh.PrivateKey) ([]byte) {
	return sK.Bytes()
}

func ConvertEdKeyPairToSodiumByte(PK ed25519.PublicKey, sK ed25519.PrivateKey) (pk,sk sodium.Bytes){
	var public_key []byte = PK
	var private_key []byte = sK
	var sodium_public_key sodium.Bytes = public_key
	var sodium_private_key sodium.Bytes = private_key
	return sodium_public_key, sodium_private_key
}

func EdKeyPairToCurve(PK ed25519.PublicKey, sK ed25519.PrivateKey) () {
}

//func SignKey(sK , )

/*
Encode encodes an X25519 public key PK into a byte sequence
The recommended encoding consists of some single-byte constant
to represent the type of curve, followed by little-endian encoding
of the u-coordinate as specified in [1].

func Encode(PK *ecdh.PublicKey) []byte {}
*/


// DH(PK1,PK2) is the shared secret output from an ecdh function involving
// keypairs involving public keys PK1 and PK2

func DH(PK1 *ecdh.PrivateKey, PK2 *ecdh.PublicKey) ([]byte, error) {
	shared, err := PK1.ECDH(PK2)
	if err != nil {
		return nil, err
	}
	return shared, nil
}


func main() {
	//IK_A,sK_A,_ := GenCurveKeyPair() // Alice keys
	//IK_B,sK_B,_ := GenCurveKeyPair() // Bob keys
	//alice_DH,_ := DH(sK_A,IK_B)
	//bob_DH,_ := DH(sK_B,IK_A)
	//fmt.Println(alice_DH,"\n")
	//fmt.Println(bob_DH,"\n")
	pubkey, prikey, _ := ed25519.GenerateKey(rand.Reader)
	t,y := ConvertEdKeyPairToSodiumByte(pubkey, prikey)
	fmt.Printf("%T", t)
	fmt.Printf("%T", y)
	//_ := t
	//_ := y
	//var pbk []byte = pubkey
	//var ppbk sodium.Bytes = pbk
	//pbk = byte(ppbk)
	//fmt.Printf("%T", ppbk)
	//fmt.Println(pubkey,"\n")
	//fmt.Println(prikey,"\n")
	//fmt.Printf("%T\n",pubkey)
	//slice := ed25519.Sign(SK,IK)
	//fmt.Println(len(slice))
	//EK,_,_ := GenKeyPair(x25519) // A user's ephemeral key
	// SPK := 
}
